{"version":3,"sources":["../../src/util/visible-area.js"],"names":["element","_element","getBoundingClientRect","_viewport","getViewportRect","area","width","height","_area","_container","getScrollableParentRect","getIntersectingRect","_visible","maxArea","Math","min","visibleArea","round","factor","roundedVisibleArea","one","two","top","max","left","right","bottom","window","innerWidth","document","documentElement","clientWidth","innerHeight","clientHeight","getInnerBoundingClientRect","rect","scrollbarWidth","offsetWidth","scrollbarHeight","offsetHeight","_rect","isOverflowingElement","style","getComputedStyle","value","getPropertyValue","isScrollableElement","scrollHeight","scrollWidth","scrollingContainers","context","slice","filter","length","reduce","previous","current","intersection"],"mappings":"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","file":"visible-area.js","sourcesContent":["\r\nimport getParents from '../get/parents';\r\n\r\nfunction getIntersectingRect(one, two) {\r\n  // identify the rectangle that _element and _container overlap in\r\n  const top = Math.max(one.top, two.top);\r\n  const left = Math.max(one.left, two.left);\r\n  // make sure bottom can't be above top, right can't be before left\r\n  const right = Math.max(Math.min(one.right, two.right), left);\r\n  const bottom = Math.max(Math.min(one.bottom, two.bottom), top);\r\n  // return something resembling ClientRect\r\n  return {\r\n    top: top,\r\n    right: right,\r\n    bottom: bottom,\r\n    left: left,\r\n    width: right - left,\r\n    height: bottom - top,\r\n  };\r\n}\r\n\r\nfunction getViewportRect() {\r\n  const width = window.innerWidth || document.documentElement.clientWidth;\r\n  const height = window.innerHeight || document.documentElement.clientHeight;\r\n  // return something resembling ClientRect\r\n  return {\r\n    top: 0,\r\n    right: width,\r\n    bottom: height,\r\n    left: 0,\r\n    width: width,\r\n    height: height,\r\n  };\r\n}\r\n\r\nfunction getInnerBoundingClientRect(element) {\r\n  // convenience for the .reduce() in getScrollableParentRect()\r\n  const rect = element.getBoundingClientRect();\r\n\r\n  // remove the width of the scrollbar because that\r\n  // area is not really considered visible\r\n  // NOTE: assuming scrollbar is always to the right and bottom\r\n  const scrollbarWidth = element.offsetWidth - element.clientWidth;\r\n  const scrollbarHeight = element.offsetHeight - element.clientHeight;\r\n  // cannot mutate rect because it has readonly properties\r\n  const _rect = {\r\n    top: rect.top,\r\n    left: rect.left,\r\n    right: rect.right - scrollbarWidth,\r\n    bottom: rect.bottom - scrollbarHeight,\r\n    width: rect.width - scrollbarWidth,\r\n    height: rect.height - scrollbarHeight,\r\n    area: 0,\r\n  };\r\n\r\n  _rect.area = _rect.width * _rect.height;\r\n  return _rect;\r\n}\r\n\r\nfunction isOverflowingElement(element) {\r\n  const style = window.getComputedStyle(element, null);\r\n  const value = 'visible';\r\n  return style.getPropertyValue('overflow-x') !== value\r\n    && style.getPropertyValue('overflow-y') !== value;\r\n}\r\n\r\nfunction isScrollableElement(element) {\r\n  // an element not scrollable if it doesn't crop its content\r\n  if (!isOverflowingElement(element)) {\r\n    return false;\r\n  }\r\n\r\n  // an element is scrollable when it is smaller than its content\r\n  return element.offsetHeight < element.scrollHeight\r\n    || element.offsetWidth < element.scrollWidth;\r\n}\r\n\r\nfunction getScrollableParentRect(element) {\r\n  // get largest possible space constrained by scrolling containers\r\n\r\n  // find scrollable parents\r\n  const scrollingContainers = getParents({context: element}).slice(1).filter(isScrollableElement);\r\n\r\n  if (!scrollingContainers.length) {\r\n    // no containers, no joy\r\n    return null;\r\n  }\r\n\r\n  // identify the currently visible intersection of all scrolling container parents\r\n  return scrollingContainers.reduce(function(previous, current) {\r\n    const rect = getInnerBoundingClientRect(current);\r\n    const intersection = getIntersectingRect(rect, previous);\r\n    // identify the smallest scrolling container so we know how much space\r\n    // our element can fill at the most - note that this is NOT the area\r\n    // of the intersection, intersection is just abused as a vehicle\r\n    intersection.area = Math.min(rect.area, previous.area);\r\n    return intersection;\r\n  }, getInnerBoundingClientRect(scrollingContainers[0]));\r\n}\r\n\r\nexport default function(element) {\r\n  // dimensions of the element itself\r\n  const _element = element.getBoundingClientRect();\r\n  // dimensions of the viewport\r\n  const _viewport = getViewportRect();\r\n  // we need the area to know how much of the element can be displayed at the most\r\n  _viewport.area = _viewport.width * _viewport.height;\r\n\r\n  let _area = _viewport;\r\n  // dimensions of the intersection of all scrollable parents\r\n  const _container = getScrollableParentRect(element);\r\n  if (_container) {\r\n    if (!_container.width || !_container.height) {\r\n      // scrollable containers without dimensions are invisible,\r\n      // meaning that the element is not visible at all\r\n      return 0;\r\n    }\r\n\r\n    // dimension the element can currently be rendered in\r\n    _area = getIntersectingRect(_container, _viewport);\r\n    _area.area = _container.area;\r\n  }\r\n\r\n  // dimension of the element currently rendered in identified space\r\n  const _visible = getIntersectingRect(_element, _area);\r\n  if (!_visible.width || !_visible.height) {\r\n    // element is not shown within the identified area\r\n    return 0;\r\n  }\r\n\r\n  // compare the element's currently visible size to the size it\r\n  // could take up at the most, being either the element's actual\r\n  // size, or the space theroetically made available if all\r\n  // scrollable parents are aligned properly\r\n  const area = _element.width * _element.height;\r\n  const maxArea = Math.min(area, _area.area);\r\n  // Firefox may return sub-pixel bounding client rect\r\n  const visibleArea = Math.round(_visible.width) * Math.round(_visible.height) / maxArea;\r\n  // Edge might not reach 0.5 exactly\r\n  const factor = 10000;\r\n  const roundedVisibleArea = Math.round(visibleArea * factor) / factor;\r\n  // clamp the value at 1\r\n  return Math.min(roundedVisibleArea, 1);\r\n}\r\n"]}
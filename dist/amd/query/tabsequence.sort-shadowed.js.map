{"version":3,"sources":["../../src/query/tabsequence.sort-shadowed.js"],"names":["elements","context","sortElements","shadows","Shadows","_elements","extractElements","length","sort","hostCounter","inHost","inDocument","hosts","host","_sortingId","parentHost","_registerHost","_registerHostParent","push","parent","element","filter","_registerElement","_injectHosts","_replaceHosts","_cleanup","Object","keys","forEach","_list","_context","shadowRoot","_merge","list","merged","resolveElement","_resolveHostElement","bind","_tabindex","concat","key"],"mappings":"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","file":"tabsequence.sort-shadowed.js","sourcesContent":["\r\nimport getShadowHost from '../get/shadow-host';\r\nimport mergeInDomOrder from '../util/merge-dom-order';\r\nimport tabindexValue from '../util/tabindex-value';\r\n\r\nclass Shadows {\r\n  constructor(context, sortElements) {\r\n    // document context we're working with\r\n    this.context = context;\r\n    // callback that sorts an array of elements\r\n    this.sortElements = sortElements;\r\n    // reference to create unique IDs for each ShadowHost\r\n    this.hostCounter = 1;\r\n    // reference map for child-ShadowHosts of a ShadowHost\r\n    this.inHost = {};\r\n    // reference map for child-ShadowHost of the document\r\n    this.inDocument = [];\r\n    // reference map for ShadowHosts\r\n    this.hosts = {};\r\n    // reference map for tabbable elements of a ShadowHost\r\n    this.elements = {};\r\n  }\r\n\r\n  // remember which hosts we have to sort within later\r\n  _registerHost(host) {\r\n    if (host._sortingId) {\r\n      return;\r\n    }\r\n\r\n    // make the ShadowHost identifiable (see cleanup() for undo)\r\n    host._sortingId = 'shadow-' + (this.hostCounter++);\r\n    this.hosts[host._sortingId] = host;\r\n\r\n    // hosts may contain other hosts\r\n    const parentHost = getShadowHost({context: host});\r\n    if (parentHost) {\r\n      this._registerHost(parentHost);\r\n      this._registerHostParent(host, parentHost);\r\n    } else {\r\n      this.inDocument.push(host);\r\n    }\r\n  }\r\n\r\n  // remember which host is the child of which other host\r\n  _registerHostParent(host, parent) {\r\n    if (!this.inHost[parent._sortingId]) {\r\n      this.inHost[parent._sortingId] = [];\r\n    }\r\n\r\n    this.inHost[parent._sortingId].push(host);\r\n  }\r\n\r\n  // remember which elements a host contains\r\n  _registerElement(element, host) {\r\n    if (!this.elements[host._sortingId]) {\r\n      this.elements[host._sortingId] = [];\r\n    }\r\n\r\n    this.elements[host._sortingId].push(element);\r\n  }\r\n\r\n  // remove shadowed elements from the sequence and register\r\n  // the ShadowHosts they belong to so we know what to sort\r\n  // later on\r\n  extractElements(elements) {\r\n    return elements.filter(function(element) {\r\n      const host = getShadowHost({ context: element });\r\n      if (!host) {\r\n        return true;\r\n      }\r\n\r\n      this._registerHost(host);\r\n      this._registerElement(element, host);\r\n      return false;\r\n    }, this);\r\n  }\r\n\r\n  // inject hosts into the sequence, sort everything,\r\n  // and recoursively replace hosts by its descendants\r\n  sort(elements) {\r\n    let _elements = this._injectHosts(elements);\r\n    _elements = this._replaceHosts(_elements);\r\n    this._cleanup();\r\n    return _elements;\r\n  }\r\n\r\n  // merge ShadowHosts into the element lists of other ShadowHosts\r\n  // or the document, then sort the individual lists\r\n  _injectHosts(elements) {\r\n    Object.keys(this.hosts).forEach(function(_sortingId) {\r\n      const _list = this.elements[_sortingId];\r\n      const _elements = this.inHost[_sortingId];\r\n      const _context = this.hosts[_sortingId].shadowRoot;\r\n      this.elements[_sortingId] = this._merge(_list, _elements, _context);\r\n    }, this);\r\n\r\n    return this._merge(elements, this.inDocument, this.context);\r\n  }\r\n\r\n  _merge(list, elements, context) {\r\n    const merged = mergeInDomOrder({\r\n      list,\r\n      elements,\r\n    });\r\n\r\n    return this.sortElements(merged, context);\r\n  }\r\n\r\n  _replaceHosts(elements) {\r\n    return mergeInDomOrder({\r\n      list: elements,\r\n      elements: this.inDocument,\r\n      resolveElement: this._resolveHostElement.bind(this),\r\n    });\r\n  }\r\n\r\n  _resolveHostElement(host) {\r\n    const merged = mergeInDomOrder({\r\n      list: this.elements[host._sortingId],\r\n      elements: this.inHost[host._sortingId],\r\n      resolveElement: this._resolveHostElement.bind(this),\r\n    });\r\n\r\n    const _tabindex = tabindexValue(host);\r\n    if (_tabindex !== null && _tabindex > -1) {\r\n      return [host].concat(merged);\r\n    }\r\n\r\n    return merged;\r\n  }\r\n\r\n  _cleanup() {\r\n    // remove those identifers we put on the ShadowHost to avoid using Map()\r\n    Object.keys(this.hosts).forEach(function(key) {\r\n      delete this.hosts[key]._sortingId;\r\n    }, this);\r\n  }\r\n}\r\n\r\nexport default function(elements, context, sortElements) {\r\n  const shadows = new Shadows(context, sortElements);\r\n  const _elements = shadows.extractElements(elements);\r\n\r\n  if (_elements.length === elements.length) {\r\n    // no shadowed content found, no need to continue\r\n    return sortElements(elements);\r\n  }\r\n\r\n  return shadows.sort(_elements);\r\n}\r\n"]}
{"version":3,"sources":["../../src/util/merge-dom-order.js"],"names":["findIndex","nodeArray","sortDomOrder","getFirstSuccessorOffset","list","target","element","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","findInsertionOffsets","elements","resolveElement","insertions","forEach","replace","offset","indexOf","length","injections","push","insertElementsAtOffsets","inserted","sort","a","b","insertion","remove","args","concat","splice","apply","_list","slice","_elements"],"mappings":";AACA;;AAEA;;;;;;;;;;;;;;;;;AAiBA,OAAOA,SAAP,MAAsB,0BAAtB;AACA,OAAOC,SAAP,MAAsB,cAAtB;AACA,OAAOC,YAAP,MAAyB,kBAAzB;;AAEA,SAASC,uBAAT,CAAiCC,IAAjC,EAAuCC,MAAvC,EAA+C;AAC7C;AACA,SAAOL,UAAUI,IAAV,EAAgB,UAASE,OAAT,EAAkB;AACvC,WAAOD,OAAOE,uBAAP,CAA+BD,OAA/B,IAA0CE,KAAKC,2BAAtD;AACD,GAFM,CAAP;AAGD;;AAED,SAASC,oBAAT,CAA8BN,IAA9B,EAAoCO,QAApC,EAA8CC,cAA9C,EAA8D;AAC5D;AACA;AACA,MAAMC,aAAa,EAAnB;AACAF,WAASG,OAAT,CAAiB,UAASR,OAAT,EAAkB;AACjC,QAAIS,UAAU,IAAd;AACA,QAAIC,SAASZ,KAAKa,OAAL,CAAaX,OAAb,CAAb;;AAEA,QAAIU,WAAW,CAAC,CAAhB,EAAmB;AACjB;AACAA,eAASb,wBAAwBC,IAAxB,EAA8BE,OAA9B,CAAT;AACAS,gBAAU,KAAV;AACD;;AAED,QAAIC,WAAW,CAAC,CAAhB,EAAmB;AACjB;AACA;AACAA,eAASZ,KAAKc,MAAd;AACD;;AAED;AACA,QAAMC,aAAalB,UAAUW,iBAAiBA,eAAeN,OAAf,CAAjB,GAA2CA,OAArD,CAAnB;AACA,QAAI,CAACa,WAAWD,MAAhB,EAAwB;AACtB;AACA;AACD;;AAEDL,eAAWO,IAAX,CAAgB;AACdJ,oBADc;AAEdD,sBAFc;AAGdJ,gBAAUQ;AAHI,KAAhB;AAKD,GA5BD;;AA8BA,SAAON,UAAP;AACD;;AAED,SAASQ,uBAAT,CAAiCjB,IAAjC,EAAuCS,UAAvC,EAAmD;AACjD;AACA;AACA,MAAIS,WAAW,CAAf;AACA;AACA;AACAT,aAAWU,IAAX,CAAgB,UAACC,CAAD,EAAIC,CAAJ;AAAA,WAAUD,EAAER,MAAF,GAAWS,EAAET,MAAvB;AAAA,GAAhB;AACAH,aAAWC,OAAX,CAAmB,UAASY,SAAT,EAAoB;AACrC;AACA,QAAMC,SAASD,UAAUX,OAAV,GAAoB,CAApB,GAAwB,CAAvC;AACA,QAAMa,OAAO,CAACF,UAAUV,MAAV,GAAmBM,QAApB,EAA8BK,MAA9B,EAAsCE,MAAtC,CAA6CH,UAAUf,QAAvD,CAAb;AACAP,SAAK0B,MAAL,CAAYC,KAAZ,CAAkB3B,IAAlB,EAAwBwB,IAAxB;AACAN,gBAAYI,UAAUf,QAAV,CAAmBO,MAAnB,GAA4BS,MAAxC;AACD,GAND;AAOD;;AAED,eAAe,YAAgD;AAAA,iFAAJ,EAAI;AAAA,MAAtCvB,IAAsC,QAAtCA,IAAsC;AAAA,MAAhCO,QAAgC,QAAhCA,QAAgC;AAAA,MAAtBC,cAAsB,QAAtBA,cAAsB;;AAC7D;AACA,MAAMoB,QAAQ5B,KAAK6B,KAAL,CAAW,CAAX,CAAd;AACA;AACA,MAAMC,YAAYjC,UAAUU,QAAV,EAAoBsB,KAApB,CAA0B,CAA1B,CAAlB;AACA/B,eAAagC,SAAb;AACA;AACA;AACA,MAAMrB,aAAaH,qBAAqBsB,KAArB,EAA4BE,SAA5B,EAAuCtB,cAAvC,CAAnB;AACA;AACAS,0BAAwBW,KAAxB,EAA+BnB,UAA/B;AACA,SAAOmB,KAAP;AACD","file":"merge-dom-order.js","sourcesContent":["\r\n// sort a list of elements into another list of elements in DOM order\r\n\r\n/*\r\n  USAGE:\r\n    mergeDomOrder({\r\n      // DOM ordered array of elements to use as base of merge\r\n      list: [],\r\n      // unordered array of elements to merge into base list\r\n      elements: [],\r\n      // callback function to resolve an element\r\n      resolveElement: function(element) {\r\n        // return null to skip\r\n        // return element to replace insertion\r\n        // return [element1, element2, â€¦] to replace insertion with multiple elements\r\n        return element;\r\n      },\r\n    })\r\n*/\r\n\r\nimport findIndex from '../util/array-find-index';\r\nimport nodeArray from './node-array';\r\nimport sortDomOrder from './sort-dom-order';\r\n\r\nfunction getFirstSuccessorOffset(list, target) {\r\n  // find the first element that comes AFTER the target element\r\n  return findIndex(list, function(element) {\r\n    return target.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_FOLLOWING;\r\n  });\r\n}\r\n\r\nfunction findInsertionOffsets(list, elements, resolveElement) {\r\n  // instead of mutating the elements list directly, remember position and map\r\n  // to inject later, when we can do this more efficiently\r\n  const insertions = [];\r\n  elements.forEach(function(element) {\r\n    let replace = true;\r\n    let offset = list.indexOf(element);\r\n\r\n    if (offset === -1) {\r\n      // element is not in target list\r\n      offset = getFirstSuccessorOffset(list, element);\r\n      replace = false;\r\n    }\r\n\r\n    if (offset === -1) {\r\n      // there is no successor in the tabsequence,\r\n      // meaning the image must be the last element\r\n      offset = list.length;\r\n    }\r\n\r\n    // allow the consumer to replace the injected element\r\n    const injections = nodeArray(resolveElement ? resolveElement(element) : element);\r\n    if (!injections.length) {\r\n      // we can't inject zero elements\r\n      return;\r\n    }\r\n\r\n    insertions.push({\r\n      offset,\r\n      replace,\r\n      elements: injections,\r\n    });\r\n  });\r\n\r\n  return insertions;\r\n}\r\n\r\nfunction insertElementsAtOffsets(list, insertions) {\r\n  // remember the number of elements we have already injected\r\n  // so we account for the caused index offset\r\n  let inserted = 0;\r\n  // make sure that we insert the elements in sequence,\r\n  // otherwise the offset compensation won't work\r\n  insertions.sort((a, b) => a.offset - b.offset);\r\n  insertions.forEach(function(insertion) {\r\n    // array.splice has an annoying function signature :(\r\n    const remove = insertion.replace ? 1 : 0;\r\n    const args = [insertion.offset + inserted, remove].concat(insertion.elements);\r\n    list.splice.apply(list, args);\r\n    inserted += insertion.elements.length - remove;\r\n  });\r\n}\r\n\r\nexport default function({list, elements, resolveElement} = {}) {\r\n  // operate on a copy so we don't mutate the original array\r\n  const _list = list.slice(0);\r\n  // make sure the elements we're injecting are provided in DOM order\r\n  const _elements = nodeArray(elements).slice(0);\r\n  sortDomOrder(_elements);\r\n  // find the offsets within the target array (list) at which to inject\r\n  // each individual element (from elements)\r\n  const insertions = findInsertionOffsets(_list, _elements, resolveElement);\r\n  // actually inject the elements into the target array at the identified positions\r\n  insertElementsAtOffsets(_list, insertions);\r\n  return _list;\r\n}\r\n"]}
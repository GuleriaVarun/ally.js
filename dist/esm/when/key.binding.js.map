{"version":3,"sources":["../../src/when/key.binding.js"],"names":["keycode","modifier","alt","ctrl","meta","shift","modifierSequence","Object","keys","map","name","createExpectedModifiers","ignoreModifiers","value","altKey","ctrlKey","metaKey","shiftKey","resolveModifiers","modifiers","indexOf","expected","forEach","token","operator","slice","propertyName","TypeError","resolveKey","key","code","parseInt","isNaN","concat","_alias","matchModifiers","event","some","prop","Boolean","text","split","_text","tokens","_modifiers","_keyCodes","keyCodes","bind"],"mappings":"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","file":"key.binding.js","sourcesContent":["\r\n/*\r\n  decodes a key binding token to a JavaScript structure\r\n\r\n  returns an array of objects:\r\n    {\r\n      // key name translated to keyCode (possibly more than one)\r\n      keyCodes: [<number>],\r\n      // translated modifiers\r\n      modifiers: {\r\n        altKey: null,   // ignore\r\n        ctrKey: false,  // expect not pressed\r\n        metaKey: true,  // expect pressed\r\n        shiftKey: true, // expect pressed\r\n      },\r\n      // callback that returns true if event's\r\n      // modifier keys match the expected state\r\n      matchModifiers: function(event){},\r\n    }\r\n*/\r\n\r\nimport keycode from '../map/keycode';\r\n\r\nconst modifier = {\r\n  alt: 'altKey',\r\n  ctrl: 'ctrlKey',\r\n  meta: 'metaKey',\r\n  shift: 'shiftKey',\r\n};\r\n\r\nconst modifierSequence = Object.keys(modifier).map(name => modifier[name]);\r\n\r\nfunction createExpectedModifiers(ignoreModifiers) {\r\n  const value = ignoreModifiers ? null : false;\r\n  return {\r\n    altKey: value,\r\n    ctrlKey: value,\r\n    metaKey: value,\r\n    shiftKey: value,\r\n  };\r\n}\r\n\r\nfunction resolveModifiers(modifiers) {\r\n  const ignoreModifiers = modifiers.indexOf('*') !== -1;\r\n  const expected = createExpectedModifiers(ignoreModifiers);\r\n\r\n  modifiers.forEach(function(token) {\r\n    if (token === '*') {\r\n      // we've already covered the all-in operator\r\n      return;\r\n    }\r\n\r\n    // we want the modifier pressed\r\n    let value = true;\r\n    const operator = token.slice(0, 1);\r\n    if (operator === '?') {\r\n      // we don't care if the modifier is pressed\r\n      value = null;\r\n    } else if (operator === '!') {\r\n      // we do not want the modifier pressed\r\n      value = false;\r\n    }\r\n\r\n    if (value !== true) {\r\n      // compensate for the modifier's operator\r\n      token = token.slice(1);\r\n    }\r\n\r\n    const propertyName = modifier[token];\r\n    if (!propertyName) {\r\n      throw new TypeError('Unknown modifier \"' + token + '\"');\r\n    }\r\n\r\n    expected[propertyName] = value;\r\n  });\r\n\r\n  return expected;\r\n}\r\n\r\nfunction resolveKey(key) {\r\n  const code = keycode[key] || parseInt(key, 10);\r\n  if (!code || typeof code !== 'number' || isNaN(code)) {\r\n    throw new TypeError('Unknown key \"' + key + '\"');\r\n  }\r\n\r\n  return [code].concat(keycode._alias[code] || []);\r\n}\r\n\r\nfunction matchModifiers(expected, event) {\r\n  // returns true on match\r\n  return !modifierSequence.some(function(prop) {\r\n    // returns true on mismatch\r\n    return typeof expected[prop] === 'boolean' && Boolean(event[prop]) !== expected[prop];\r\n  });\r\n}\r\n\r\nexport default function(text) {\r\n  return text.split(/\\s+/).map(function(_text) {\r\n    const tokens = _text.split('+');\r\n    const _modifiers = resolveModifiers(tokens.slice(0, -1));\r\n    const _keyCodes = resolveKey(tokens.slice(-1));\r\n    return {\r\n      keyCodes: _keyCodes,\r\n      modifiers: _modifiers,\r\n      matchModifiers: matchModifiers.bind(null, _modifiers),\r\n    };\r\n  });\r\n}\r\n"]}
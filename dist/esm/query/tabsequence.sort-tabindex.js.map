{"version":3,"sources":["../../src/query/tabsequence.sort-tabindex.js"],"names":["tabindexValue","elements","map","indexes","normal","filter","element","tabIndex","undefined","push","_elements","sort","reduceRight","previous","current","concat"],"mappings":";AACA,OAAOA,aAAP,MAA0B,wBAA1B;;AAEA,eAAe,UAASC,QAAT,EAAmB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAMC,MAAM,EAAZ;AACA,MAAMC,UAAU,EAAhB;AACA,MAAMC,SAASH,SAASI,MAAT,CAAgB,UAASC,OAAT,EAAkB;AAC/C;AACA,QAAIC,WAAWD,QAAQC,QAAvB;AACA,QAAIA,aAAaC,SAAjB,EAA4B;AAC1BD,iBAAWP,cAAcM,OAAd,CAAX;AACD;;AAED;AACA,QAAIC,YAAY,CAAZ,IAAiBA,aAAa,IAA9B,IAAsCA,aAAaC,SAAvD,EAAkE;AAChE,aAAO,IAAP;AACD;;AAED,QAAI,CAACN,IAAIK,QAAJ,CAAL,EAAoB;AAClB;AACAL,UAAIK,QAAJ,IAAgB,EAAhB;AACA;AACAJ,cAAQM,IAAR,CAAaF,QAAb;AACD;;AAED;AACAL,QAAIK,QAAJ,EAAcE,IAAd,CAAmBH,OAAnB;AACA;AACA,WAAO,KAAP;AACD,GAvBc,CAAf;;AAyBA;AACA;AACA;AACA,MAAMI,YAAYP,QAAQQ,IAAR,GAAeT,GAAf,CAAmB,UAASK,QAAT,EAAmB;AACtD,WAAOL,IAAIK,QAAJ,CAAP;AACD,GAFiB,EAEfK,WAFe,CAEH,UAASC,QAAT,EAAmBC,OAAnB,EAA4B;AACzC,WAAOA,QAAQC,MAAR,CAAeF,QAAf,CAAP;AACD,GAJiB,EAIfT,MAJe,CAAlB;;AAMA,SAAOM,SAAP;AACD","file":"tabsequence.sort-tabindex.js","sourcesContent":["\r\nimport tabindexValue from '../util/tabindex-value';\r\n\r\nexport default function(elements) {\r\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement.tabIndex\r\n  // elements with tabIndex \"0\" (including tabbableElements without tabIndex) should be navigated in the order they appear.\r\n  // elements with a positive tabIndex:\r\n  //   Elements that have identical tabIndexes should be navigated in the order they appear.\r\n  //   Navigation proceeds from the lowest tabIndex to the highest tabIndex.\r\n\r\n  // NOTE: sort implementation may be unstable and thus mess up DOM order,\r\n  // that's why we build a map that's being sorted instead. If we were able to rely\r\n  // on a stable sorting algorithm, sortTabindex() could be as simple as\r\n  // elements.sort(function(a, b) { return a.tabIndex - b.tabIndex; });\r\n  // at this time Chrome does not use a stable sorting algorithm\r\n  // see http://blog.rodneyrehm.de/archives/14-Sorting-Were-Doing-It-Wrong.html#stability\r\n\r\n  // NOTE: compareDocumentPosition seemed like more overhead than just sorting this with buckets\r\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node.compareDocumentPosition\r\n\r\n  const map = {};\r\n  const indexes = [];\r\n  const normal = elements.filter(function(element) {\r\n    // in Trident and Gecko SVGElement does not know about the tabIndex property\r\n    let tabIndex = element.tabIndex;\r\n    if (tabIndex === undefined) {\r\n      tabIndex = tabindexValue(element);\r\n    }\r\n\r\n    // extract elements that don't need sorting\r\n    if (tabIndex <= 0 || tabIndex === null || tabIndex === undefined) {\r\n      return true;\r\n    }\r\n\r\n    if (!map[tabIndex]) {\r\n      // create sortable bucket for dom-order-preservation of elements with the same tabIndex\r\n      map[tabIndex] = [];\r\n      // maintain a list of unique tabIndexes\r\n      indexes.push(tabIndex);\r\n    }\r\n\r\n    // sort element into the proper bucket\r\n    map[tabIndex].push(element);\r\n    // element moved to sorting map, so not \"normal\" anymore\r\n    return false;\r\n  });\r\n\r\n  // sort the tabindex ascending,\r\n  // then resolve them to their appropriate buckets,\r\n  // then flatten the array of arrays to an array\r\n  const _elements = indexes.sort().map(function(tabIndex) {\r\n    return map[tabIndex];\r\n  }).reduceRight(function(previous, current) {\r\n    return current.concat(previous);\r\n  }, normal);\r\n\r\n  return _elements;\r\n}\r\n"]}